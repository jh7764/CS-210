
//Distatance problem #1
import stdlib.StdArrayIO;
import stdlib.StdOut;

public class Distance {
    // Entry point. [DO NOT EDIT]
    public static void main(String[] args) {
        double[] x = StdArrayIO.readDouble1D();
        double[] y = StdArrayIO.readDouble1D();
        StdOut.println(distance(x, y));
    }


    // Returns the Euclidean distance between the position vectors x and y.
    private static double distance(double[] x, double[] y) {
        // Sum up the squares of (x[i] - y[i]), where 0 <= i < x.length, and return the square
        // root of the sum.
        double sumofsquares = 0.0;
        for (int i = 0; i < x.length; i++) {
            sumofsquares += Math.pow((x[i] - y[i]), 2);
        }
        return Math.sqrt(sumofsquares);
    }
}


//Great Circle problem #2
import stdlib.StdOut;

public class GreatCircle {
    // Entry point.
    public static void main(String[] args) {
        // Accept x1 (double), y1 (double), x2 (double), and y2 (double) as command-line arguments.
        double x1 = Double.parseDouble(args[0]);
        double y1 = Double.parseDouble(args[1]);
        double x2 = Double.parseDouble(args[2]);
        double y2 = Double.parseDouble(args[3]);


        // Convert the angles to radians.
        x1 = Math.toRadians(x1);
        y1 = Math.toRadians(y1);
        x2 = Math.toRadians(x2);
        y2 = Math.toRadians(y2);

        // Calculate great-circle distance d.
        double d = 6359.83*Math.acos((Math.sin(x1)*Math.sin(x2) + Math.cos(x1)*Math.cos(x2)*Math.cos(y1-y2)));

        // Write d to standard output.
        StdOut.println(d);
    }
}


//Harmonic problem #3
Harmoimport stdlib.StdOut;

public class Harmonic {
    // Entry point.
    public static void main(String[] args) {
        // Accept n (int) as command-line argument.
        int n = Integer.parseInt(args[0]);

        // Set total to the rational number 0.
        Rational total = new Rational (0);

        // For each 1 <= i <= n, add the rational term 1 / i to total.
        for (long i = 1; i <= n; i++){
            total = total.add(new Rational (1, i));
        }

        // Write total to standard output.
        StdOut.println(total);
    }
}


//Prime Counter problem #4
import stdlib.StdOut;

public class PrimeCounter {
    // Entry point. [DO NOT EDIT]
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        StdOut.println(primes(n));
    }

    // Returns true if x is prime; and false otherwise.
    private static boolean isPrime(int x) {
        // For each 2 <= i <= x / i, if x is divisible by i, then x is not a prime. If no such i
        // exists, then x is a prime.
        for (int i = 2; i <= x / (double) i; i++) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }
   // Returns the number of primes <= n.
    private static int primes(int n) {
        // For each 2 <= i <= n, use isPrime() to test if i is prime, and if so increment a count.
        // At the end return the count.
        int primes = 0;
        for (int i = 2; i <= n; i++) {
            primes += isPrime(i) ? 1 : 0;
        }
        return primes;
    }
}

//Rational poblem #5
import stdlib.StdOut;

public class Rational {
    private long x; // numerator
    private long y; // denominator

    // Constructs a rational number whose numerator is x and denominator is 1.
    public Rational(long x) {
        // Set this.x to x and this.y to 1.
        this.x = x;
        this.y = 1;
    }

    // Constructs a rational number given its numerator x and denominator y.
    public Rational(long x, long y) {
        // Set this.x to x / gcd(x, y) and this.y to y / gcd(x, y).
        this.x = x / gcd(x, y);
        this.y = y / gcd(x, y);
    }


    // Returns the sum of this rational number and other.
    public Rational add(Rational other) {
        // Sum of rationals a/b and c/d is the rational (ad + bc) / bd
        long numerator = (this.x * other.y + this.y * other.x );
        long denominator = (this.y * other.y);
        return new Rational(numerator, denominator);
    }

    // Returns the product of this rational number and other.
    public Rational multiply(Rational other) {
        // Product of rationals a/b and c/d is the rational ac / bd.
        long num = (other.x * this.x);
        long den = (other.y * this.y);
        return new Rational(num, den);
    }

    // Returns true if this rational number is equal to other, and false otherwise.
    public boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        if (other == this) {
            return true;
        }
        if (other.getClass() != this.getClass()) {
            return false;
        }

        // Rationals a/b and c/d are equal iff a == c and b == d.
        Rational rational = (Rational)other;
        return (this.x == rational.x && this.y == rational.y);

    }

    // Returns a string representation of this rational number.
    public String toString() {
        long a = x, b = y;
        if (a == 0 || b == 1) {
            return a + "";
        }
        if (b < 0) {
            a *= -1;
            b *= -1;
        }
        return a + "/" + b;
    }

    // Returns gcd(p, q), computed using Euclid's algorithm.
    private static long gcd(long p, long q) {
        return q == 0 ? p : gcd(q, p % q);
    }

    // Unit tests the data type. [DO NOT EDIT]
    public static void main(String[] args) {
        int n = Integer.parseInt(args[0]);
        Rational total = new Rational(0);
        Rational term = new Rational(1);
        for (int i = 1; i <= n; i++) {
            total = total.add(term);
            term = term.multiply(new Rational(1, 2));
        }
        Rational expected = new Rational((long) Math.pow(2, n) - 1, (long) Math.pow(2, n - 1));
        StdOut.printf("a           = 1 + 1/2 + 1/4 + ... + 1/2^%d = %s\n", n, total);
        StdOut.printf("b           = (2^%d - 1) / 2^(%d - 1) = %s\n", n, n, expected);
        StdOut.printf("a.equals(b) = %b\n", total.equals(expected));
    }
}


//Transpose problem #6
import stdlib.StdArrayIO;

public class Transpose {
    // Entry point. [DO NOT EDIT]
    public static void main(String[] args) {
        double[][] x = StdArrayIO.readDouble2D();
        StdArrayIO.print(transpose(x));
    }

    // Returns a new matrix that is the transpose of x.
    private static double[][] transpose(double[][] x) {
        // Create a new 2D matrix t (for transpose) with dimensions n x m, where m x n are the
        // dimensions of x.
        int m = x.length;
        int n = x[0].length;
        double[][] t = new double[n][m];

        // For each 0 <= i < m and 0 <= j < n, set t[j][i] to x[i][j].
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                t[j][i] = x[i][j];
            }
        }

        // Return t.
        return t;
    }
}
